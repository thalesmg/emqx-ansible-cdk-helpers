---

- name: define hosts
  hosts: localhost
  gather_facts: no
  roles:
    - define_inventory

- name: check inputs
  hosts: localhost
  gather_facts: no
  tasks:
    - name: ensure vars are defined
      fail:
        msg: "{{ item }} must be defined!"
      when: lookup('vars', item) is undefined
      loop:
        - emqx_script_result_file
        - emqx_bastion_server
        - emqx_test_script_file
        - emqtt_bench_interval
        - emqtt_bench_number_of_connections
        - emqtt_bench_session_expiry_interval
        - script_timezone
    - name: ensure test exists
      # delegate_to: localhost
      stat:
        path: "templates/{{ emqx_test_script_file }}"
      register: script_file_stat
    - name: ensure test exists
      fail:
        msg: "test script {{ emqx_test_script_file }} does not exist!"
      when: not script_file_stat.stat.exists
    - debug:
        msg: |
          script: {{ emqx_test_script_file }}

- name: run and record tests
  hosts: loadgen
  become: yes
  become_user: root
  force_handlers: True
  # strategy: free
  # max_fail_percentage: 0
  tasks:
    - name: copy script
      template:
        src: "{{ emqx_test_script_file }}"
        dest: /root/emqtt-bench/
        mode: '0777'
    - name: run the scripts
      shell: |
        cd /root/emqtt-bench/
        for i in $(seq {{ start_n }} {{ (start_n | int) + (num_procs | int) - 1 }})
        do
          nohup timeout {{ timeout }}s ./{{ emqx_test_script_file }} $i {{ emqx_script_result_file }} >/dev/null &
          echo $!
        done
      register: test_runner
      vars:
        timeout: "{{ script_timeout_s | default('300') }}"
        num_procs: "{{ emqx_test_procs | default(1) | int }}"
        start_n: "{{ (loadgen_num * (emqx_test_procs | default(1) | int)) | int }}"
    # - debug:
    #     var: test_runner
    - name: give the scripts some time...
      pause:
        seconds: "{{ script_timeout_s | default('300') }}"
    # - name: kill the scripts
    #   shell: "kill -9 $(ps -o pid= --ppid {{ test_runner.stdout }})"
    #   ignore_errors: yes
    - name: REALLY kill the scripts
      shell: "ps -ef | grep bench | grep -v grep | awk '{print $2}' | xargs kill -9"
      # shell: "pkill beam"
      ignore_errors: yes
    # - name: fetch output
    #   tags: [collect]
    #   fetch:
    #     src: "/tmp/{{ emqx_script_result_file }}"
    #     dest: "./tmp/data/{{ emqx_script_result_file }}/{{ inventory_hostname_short }}"
    #     flat: yes

- name: collect logs
  hosts: emqx
  become: yes
  become_user: root
  tasks:
    - name: produce node_dump
      shell: "/usr/lib/emqx/bin/node_dump"
      register: node_dump_invoke
      ignore_errors: yes
    - name: find node dump location
      when: not node_dump_invoke.failed
      set_fact:
        node_dump_path: "{{ node_dump_invoke.stdout | regex_search(regexp, '\\1') }}"
      vars:
        regexp: "Created a node dump (.+)"
    - name: fetch node dump
      when: not node_dump_invoke.failed and node_dump_path is defined and node_dump_path
      fetch:
        src: "{{ node_dump_path[0] }}"
        dest: "./tmp/data/{{ emqx_script_result_file }}/{{ inventory_hostname_short }}-node_dump.tar.gz"
        flat: yes
    - name: crashdump?
      stat:
        path: "/var/log/emqx/erl_crash.dump"
      register: crashdump_stat
    - name: syslog?
      stat:
        path: "/var/log/syslog"
      register: syslog_stat
    - name: fetch crashdump
      when: crashdump_stat.stat.exists
      fetch:
        src: "{{ crashdump_stat.stat.path }}"
        dest: "./tmp/data/{{ emqx_script_result_file }}/{{ inventory_hostname_short }}-crashdump"
        flat: yes
    - name: fetch syslog
      when: syslog_stat.stat.exists
      fetch:
        src: "{{ syslog_stat.stat.path }}"
        dest: "./tmp/data/{{ emqx_script_result_file }}/{{ inventory_hostname_short }}-syslog"
        flat: yes
    - name: find mem ets dumps
      shell: "ls /tmp/*_mem-ets-dump.txt 2>/dev/null || true"
      register: mem_ets_dumps
    - name: tar mem ets dumps
      when: mem_ets_dumps.stdout_lines
      shell: |
        cd /tmp
        tar -cjf {{ emqx_script_result_file }}.mem-ets-dump.tar.bz2 *_mem-ets-dump.txt
    - name: fetch mem ets dumps
      when: mem_ets_dumps.stdout_lines
      fetch:
        src: "/tmp/{{ emqx_script_result_file }}.mem-ets-dump.tar.bz2"
        dest: "./tmp/data/{{ emqx_script_result_file }}/{{ inventory_hostname_short }}-mem-ets-dump.tar.bz2"
        flat: yes

# - name: test
#   hosts: localhost
#   tags: [collect]
#   tasks:
#     - name: compress
#       archive:
#         path:
#           - './tmp/data/{{ emqx_script_result_file }}/*'
#         dest: "./tmp/data/{{ emqx_script_result_file }}.tar.bz2"
#         remove: yes
#         format: bz2

...
